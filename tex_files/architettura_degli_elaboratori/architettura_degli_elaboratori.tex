\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb} % Math packages
\usepackage{geometry}
\usepackage{hyperref} % Clickable links
\usepackage{graphicx} % Images

\geometry{a4paper, margin=1in}

\title{Architettura degli elaboratori}
\author{Matteo}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
Un calcolatore è un sistema composto da processsori, memorie, e dispositivi di input/output.
un \textbf{Bus} è un insieme di connessioni elettriche parallele che trasportano dati da un componente all'altro.

Nell'architettura di Von Neumann viene introdotta l'idea di usare la memoria non solo per i dati ma anche per il programma.

Collega la cpu e la memoria con un bus indirizzi, indicando la posizione dei dati. 
Mentre su un altro bus dati memoria e cpu si scambiano i dati veri e propri.

CPU composta date
\begin{itemize}
\item Unita di controllo: legge e interpreta le istruzioni.
\item Unita aritmetico logica (ALU): esegue operazioni aritmetiche e logiche.
\item registri: memorie veloci interne alla cpu.
\end{itemize}

ci sono diversi registri specializzati:
\begin{itemize}
\item Program counter (PC): indica la prossima istruzione da eseguire.
\item Memory address register (MAR): contiene l'indirizzo di memoria da cui leggere o scrivere dati.
\item Memory data register (MDR): registro che accede ai bus dei dati.
\item Instruction register (IR): contiene l'istruzione che si sta per eseguire.
\item Program status word (PSW): contiene informazioni sullo stato della CPU.
\end{itemize}

in pratica il ciclo di esecuzione di un'istruzione è:
\begin{enumerate}
    \item il contenuto di PC viene copiato in MAR e inviato alla memoria attraverso il bus indirizzi.
    \item la memoria risponde inviando il dato all'MDR attraverso il bus dati.
    \item il contenuto di MDR viene copiato in IR e decodificato.
    \item l'istruzione passa alla ALU per essere eseguita.
    \item se servono altri dati vengono letti dalla memoria nello stesso modo.
    \item se serve il risultato e copiato in memoria attraverso MDR
    \item il PC viene aggiornato per puntare alla prossima istruzione.
\end{enumerate}
 Questo ciclo e chiamato \textbf{fetch-decode-execute cycle}.

 \textbf{data path}: insieme di registri e ALU che eseguono operazioni sui dati.

 il percorso dei dati da memoria ad ALU, la loro esecuzione e il ritorno in memoria viene chiamato \textbf{ciclo di data path}, ed e governato da un clock.

 durata ciclo di data path o ciclo di clock= 1/F, dove F e la frequenza di lavoro della CPU(cicli al secondo), misurata in heartz.

 la velocita di esecuzione delle istruzioni ISA(instruction set architecture), è misurata con la durata di un ciclo di clock per i cicli necessari.

 fissato il ciclo di clock, la velocita puo essere aumentata con il parallelismo.

 negli anni 70 si sviluppo la differenza tra CISC e RISC.
  CISC: complex instruction set computer, set di istruzioni complesso, con istruzioni che fanno operazioni complesse in un singolo ciclo.
  RISC: reduced instruction set computer, set di istruzioni ridotto, con istruzioni semplici che richiedono piu cicli per operazioni complesse.

  Risc usa la microprogrammazione, in modo da far fare diverse operazioni a pochi componenti.\\

  piu cicli FDE possono essere eseguiti insieme con il \textbf{pipelining}

  si sviluppano anche architetture che permettono il parallelismo.
  , ad esempio cpu con piu ALU e control units.

  oppure molte cpu possono lavorare in modo coordinato sulla stessa istruzione su dati diversi, creando un \textbf{array computer}

se invece eseguono istruzioni diverse su dati, con una memoria condivisa, diversi si parla di \textbf{multiprocessor systems}.

la forma piu complessa sono i \textbf{multicomputer systems}, con piu cpu, ognuna con memoria propria, collegate in rete.

\subsection{memoria}

vari tipi di memoria
\begin{itemize}
\item memoria volatile: perde il contenuto quando viene spenta(es:ram).
\item memoria non volatile: mantiene il contenuto quando spenta(es:rom, hard disk).
\item memoria online: sempre accessibile
\item memoria offline: il supporto deve essere montato
\end{itemize}

la memoria si organizza in celle, ogni cella è una sequenza di bit con il proprio indirizzo.

cella di 8 bit=byte.

molti calcolatori lavorano su blocchi da 32 o 64 bit, questi blocchi si chiamano word.

le word possono essere memorizzate in celle standard, occupando piu celle consecutive.
si puo fare in 2 modi:
\begin{itemize}
    \item big-endian: byte piu significativo all'indirizzo piu basso.
    \item little-endian: byte meno significativo all'indirizzo piu basso.
\end{itemize}

la \textbf{cache} è una memoria poco capiente ma  veloce, che viene usata per contenere le word piu usate.

la cpu prima cerca i dati nella cache, se non li trova li va a prendere in memoria principale.

\textbf{principio di località}: dati usati recentemente gli uni dagli altri sono spesso in locazoni vicine.

tipi di supporti:
\begin{itemize}
\item hard disk: memoria non volatile, lenta, grande capacita, usa piatti magnetici rotanti.(puo essere resa piu veloce con la tecnica RAID, che usa piu dischi in parallelo).
\item SSD: memoria non volatile, veloce, grande capacita, usa memoria flash, piu veloce ma meno capiente.
\item CD e DVD: memoria non volatile, usano supporti ottici, capacita limitata.
\end{itemize}

\section{porte logiche e circuiti combinatori}
Porte logiche sono basate sull'algebra di Boole, un'espressione booleana si costruisce con: le costanti di boole(0,1), gli opeartori booleani, e variabili(x,y, ecc..).

\textbf{mintermine}: un prodotto (AND) di tutte le variabili della funzione, ognuna presente una sola volta, negata o non negata, che vale 1 per una sola combinazione di valori delle variabili.

\textbf{forma canonica}: l'OR di tutti mintermini veri

porta nand è una porta logica utile per costruire circuiti combinatori, falsa solo quando a=1 e b=1.
è universale e facile da costruire con transistor

array logici programmmabili: collegando dei fusibili è possibile creare porte logiche personalizzate.

\subsection{mappe di karnaugh}

\textbf{mappe di karnaugh}: modo di rappresentare funzioni booleane. permettono di costruire un circuito combinatorio minimale.

tabella bidimensionale in cui ogni mintermine ha una cella, e la cella ha un valore, 1 se vale, se 0 se no.

puoi creare raggruppamenti che comprendono gruppi di certi letterali =1.

all'interno di una mappa di karnaugh una copertura si dice minimale quando:
\begin{itemize}
\item i suoi raggruppamenti non è contenuto in raggruppamenti piu grandi.
\item i suoi raggruppamenti contengono almeno una cella che non appare in altri raggruppamenti della copertura
\end{itemize}

\subsection{bus multi bit}

circuiti combinatori collegati a connessioni da piu bit sono detti \textbf{bus}

sono praticamente un raggruppamento di segnali e ogni coppia lavora separatamente come in una porta normale, per poi far uscire i seganli uno dopo l'altro.

\section{codice binario}
codifiche posizionali principali:
\begin{itemize}
\item binario
\item ottale
\item esadecimale
\end{itemize}

per convertire da bianrio a ottale prendi 3 cifre alla volta e calcola il numero, per esadecimale prendine 4.

i numeri possono anche essere codificati \textbf{in eccesso} cioe dato k= bits e bias= $2^{k-1}$. somma numero e bias, e codifica regolarmente il risultato.
 
es: -127 + bias(128) = 1.    1= 00000001

se poi vuoi decodificare, decodifica il binario nel numero e sottrai il bias.

nelle somme tra binari, il riporto finale nel complemento a 1 viene sommato all'inizio, nel complemento a 2 viene scartato.

puo verificarsi \textbf{overflow}: se i due addendi hanno segni diversi non accade mai, se hanno lo stesso segno e il risultato ha segno opposto, si verifica overflow.

\subsection{codifica  a virgola mobile}

composto da sue parti: \textbf{mantissa}(o frazione): numero, ed \textbf{esponente}: potenza

le operazioni su numeri floating point(virgola mobile) possono dare 2 tipi di errore
\begin{itemize}
\item overflow: numero in valore assoluto troppo grande
\item underflow: numero in valore assoluto troppo piccolo
\end{itemize}

\textbf{normalizzare} un numero significa scrivere un numero in una forma standard dove la mantissa ha sempre la stessa struttura.

in binario vuoi fare in modo che il numero piu significativo della mantissa(il primo) sia 1.

puoi farlo spostando il primo 1 a sinistra di x posti e poi sottraendo x all'esponente e ricodificandolo.

\subsection{standard di codifica}
IEEE 754 è lo standard piu usato per i floating point. definisce diversi formati tra cui Binary32 che usa 1 bit di segno, 8 di esponente e 23 di mantissa.

era impossibile codificare caratteri extraeuropei in ASCII quindi fu creato UNICODE, che usava 16 bit.
UNICODE pero usa troppi bit per i caratteri piu semplici ed e vicino oramai all'esaurimento, quindi fu creato UTF-8.
UTF-8 puo dinamicamente occupare da 1 a 4 byte, I bit iniziali indicano il formato specifico e la quantità di
bit utilizzati.

\subsection{bit di controllo}

i codici binari o in lettura o in scrittura possono essere soggette a errori, per evitare questo esistono i bit di controllo.

esistono sia bit di rilevazione che di correzione.\\

\textbf{distanza di Hamming}: è il numero di bit di differenza tra due parole. la distanza di hamming di un codice è invece la minima dist. di Hamming tra tutte  le parole del codice.

per rilevare d bit errati servono, la distanza di Hamming deve essere uguale a d+1, per correggerli deve essere d+2.

uno dei codici di controllo piu semplici e il \textbf{bit di parita}: un bit che fa in modo che il numero di 1 sia pari, la dist. di hamming minima risulta essere 2.

i bit di parita devono sempre rispettare l'equazione m(numero bit)+ r(num bit di contollo)+1 minore o uguale a $2^r$
e vanno collocati nelle posizioni equivalenti alle potenze di 2 (1,2,4,8,16 ....) e ognuno controlla un sottogruppo di bit.


\section{circuiti sequenziali}

alcuni circuiti possono memorizzare l'input in e ripeterlo, in questi casi l'output non dipende piu solo dall'input, ma anche da altre circostanze.

un esempio e il latch SR. il circuito contiene un ciclo e se entrambi gli input sono 0 il risultato e sconosiuto.

si puo fare in modo che il latch risponda agli input solo durante certi momenti mettendo gli input e il ciclo di clock in porte AND

il latch D ha un solo input e cio fa in modo che non si verifichi la situazion in cui entrambi gli input sono 1.

Il latch D cambia il proprio stato mentre il clock è attivo, durante la
fase 0 del clock memorizza l’ultimo valore di D alla fine della fase 1

i circuiti con \textbf{commutazione sul fronte}: ovvero due stati stabili che cambiano in base al clock, sono detti flip-flop

esistono vari flip-flop, noi usiamo il tipo D.

il DFF(flip-flop tipo D) cambia stato dopo il fronte di salita in base in base agli input che ha ricevuto durante il fronte di salita.

gli \textbf{one-bit-register}: memorizzano un bit nell'ultimo istante in cui load e stato attivato

collegando tanti one-bit-registers puoi creare un w-bit-register

esiste anche il \textbf{counter}: e un fcircuito sequenziale usato per crare i program counter, oltre a load ha reset che resetta a 0 il bit interno e inc che aumenta di 1 il valore memorizzato. se nessuno di questi comandi e usato ripete solo il val memorizzato.

una memoria con locazioni da w bit puo essere realizzata con w-bit-registers e un circuito chiamato DIrect Access Logic indica a quale accedere.
cosi si realizzano registri di memoria.

puo essere utili avere circuiti logici anche dopo le uscite delle memorie per indicare quale delle uscite dei registri deve essere portata su out.

\section{microarchitettura}

il livello della microarchitettura si occupa di utilizzare le parti del livello logico digitale per creare linguaggio macchina.

il processore hack ad esempio ha due registri D e d A che possono dare alla ALU i suoi 2 input,D puo contenere un precedente output, A un'istruzione o un precedente output.

il flusso dei dati tra componenti viene gestito con MUX.

i MUX e i bit di controllo vengono gestiti da una microarchitettura di circuiti combinatori. L'intero ciclo FDE viene completato in un clock.\\

le memorie realizzate con flip-flop sono dette SRAM, sono veloci ma costose per quanto riguarda il costo in bit.

SRAM vengono quindi usate per la cache , DRAM per la memoria centrale, e poi dischi.

il passaggio da una memoria all'altra si gestisce con paginazione.

Le DRAM o RAM dinamiche hanno un solo transister e un condensatore, che mantiene un bit.

visto che il condesatore puo perdere la propria carica, sono necessari periodi di refresh, cio le rende piu lente.

ci sono poi vari livelli di cache.

una piu piccola dentro al cip della CPU, una media nello stesso involucro della CPU e una piu grande esterna\\

con \textbf{localita temporale} si intende l'alta probabilita che la stessa cella venga acceduta in una breve distanza di tempo

con \textbf{localita spaziale} si intende l'alta probabilita che celle di memoria vicine vengano accedute a breve distanza di tempo.

esistono diversi metodi di gestione della cache. noi vediamo il "cache a corrispondenza diretta" o "direct mapped cache".

suddividi la memoria in blocchi di dimensione m.

crei n linee di cache di dimensione m. le linee sono iindicizzate da 0 a n-1.

blocchi di memoria vengono inseriti in certe linee di cache "ad orologio", e si tiene conto di quale blocco e dove.

ogni linea ha 1 booleano Valid che dice se la linea e occupta, data che contiene i dati e tag che indica il blocco della emoria principale contenuto.

quando l'accesso alla cache ha successo e il blocco di memoria e gia presente in cache, si dice che e avvenuto un cache hit, altrimenti e cache miss.
se cache miss, il blocco deve essere portato in cache, qui ce un momento in cui dati di cache e dati di memoria centrale non corrispondono, cio puo creare problemi.

esistono gli stessi prooblemi tra memoria centrale e memoria di massa(dischi), qui si usa la paginazione.\\

a differenza del processore hack, istruzione e operandi spesso sono caricate insieme, questo richiede un ciclo di clock molto lungo.

spesso si pre-carica la prossimo istruzione mentre la prima e in esecuzione, questo e gestito dall' IFU( instruction fetch unit)
Questo e un esempio di pipeline.

i salti pero possono essere problematici per le pipeline, visto che richiedono di scartare le istruzioni successive.
quindi architetture moderne cercano di predire i salti.

ci sono anche problemi di concorrenza e accesso a sezioni critiche.

\section{ISA del processore hack}

per usare un processore lo si deve programmare tramite un suo linguaggio assembly, un set di istruzioni detto "instruction set".

il linguaggio assembly corrisponde ad istruzioni macchina subito eseguibili. e praticamente una versione leggibile del binario.

il linguaggio macchina supportato dall'architettura dipende dall'instrucion set architecture(ISA)

possiamo definire l'ISA come l'insieme degli elementi dell'architettura visibili al compilatore.

ci sono due approcci per migliorare le architetture: RISC e CISC

la hack non e facilmente classificabile.

hack e una macchina a 16 bit costituita da 
\begin{itemize}
\item RAM: composta da registri a 16 bit. salva dati di lavoro
\item ROM: composta da registri a 16 bit, contiene istruzioni dei programmi da eseguire.
\item registro A
\item registro D
\item M: registro di memoria puntato da A
\item ALU per eseguire poi le istruzioni.
\item program counter: il registro che contiene l'indirizzo del registro ROM con la prossima istruzione.
\end{itemize}

esistono 2 tipi di istruzioni:
\begin{itemize}
\item A instruction: servono solo a caricare valori sul registro A.
\item C instruction: istruzioni che eseguono una computazione prelevando dai registri A, D ed M e poi registrando il nuovo valore.
\end{itemize}

le istruzioni C hanno 3 parti:
\begin{itemize}
\item dest: specifica dove memorizzare la computazione.
\item comp: specifica la computazione da eseguire.
\item jump: specifica se, dopo avere eseguito dest=comp, bisogna saltare a un'altra istruzione. Lo fa dicendo di aggiornare il PC al valore del registro A.

\end{itemize}





\end{document}

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb} % Math packages
\usepackage{geometry}
\usepackage{hyperref} % Clickable links
\usepackage{graphicx} % Images

\geometry{a4paper, margin=1in}

\title{Architettura degli elaboratori}
\author{Matteo}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
Un calcolatore è un sistema composto da processsori, memorie, e dispositivi di input/output.
un \textbf{Bus} è un insieme di connessioni elettriche parallele che trasportano dati da un componente all'altro.

Nell'architettura di Von Neumann viene introdotta l'idea di usare la memoria non solo per i dati ma anche per il programma.

Collega la cpu e la memoria con un bus indirizzi, indicando la posizione dei dati. 
Mentre su un altro bus dati memoria e cpu si scambiano i dati veri e propri.

CPU composta date
\begin{itemize}
\item Unita di controllo: legge e interpreta le istruzioni.
\item Unita aritmetico logica (ALU): esegue operazioni aritmetiche e logiche.
\item registri: memorie veloci interne alla cpu.
\end{itemize}

ci sono diversi registri specializzati:
\begin{itemize}
\item Program counter (PC): indica la prossima istruzione da eseguire.
\item Memory address register (MAR): contiene l'indirizzo di memoria da cui leggere o scrivere dati.
\item Memory data register (MDR): registro che accede ai bus dei dati.
\item Instruction register (IR): contiene l'istruzione che si sta per eseguire.
\item Program status word (PSW): contiene informazioni sullo stato della CPU.
\end{itemize}

in pratica il ciclo di esecuzione di un'istruzione è:
\begin{enumerate}
    \item il contenuto di PC viene copiato in MAR e inviato alla memoria attraverso il bus indirizzi.
    \item la memoria risponde inviando il dato all'MDR attraverso il bus dati.
    \item il contenuto di MDR viene copiato in IR e decodificato.
    \item l'istruzione passa alla ALU per essere eseguita.
    \item se servono altri dati vengono letti dalla memoria nello stesso modo.
    \item se serve il risultato e copiato in memoria attraverso MDR
    \item il PC viene aggiornato per puntare alla prossima istruzione.
\end{enumerate}
 Questo ciclo e chiamato \textbf{fetch-decode-execute cycle}.

 \textbf{data path}: insieme di registri e ALU che eseguono operazioni sui dati.

 il percorso dei dati da memoria ad ALU, la loro esecuzione e il ritorno in memoria viene chiamato \textbf{ciclo di data path}, ed e governato da un clock.

 durata ciclo di data path o ciclo di clock= 1/F, dove F e la frequenza di lavoro della CPU(cicli al secondo), misurata in heartz.

 la velocita di esecuzione delle istruzioni ISA(instruction set architecture), è misurata con la durata di un ciclo di clock per i cicli necessari.

 fissato il ciclo di clock, la velocita puo essere aumentata con il parallelismo.

 negli anni 70 si sviluppo la differenza tra CISC e RISC.
  CISC: complex instruction set computer, set di istruzioni complesso, con istruzioni che fanno operazioni complesse in un singolo ciclo.
  RISC: reduced instruction set computer, set di istruzioni ridotto, con istruzioni semplici che richiedono piu cicli per operazioni complesse.

  Risc usa la microprogrammazione, in modo da far fare diverse operazioni a pochi componenti.\\

  piu cicli FDE possono essere eseguiti insieme con il \textbf{pipelining}

  si sviluppano anche architetture che permettono il parallelismo.
  , ad esempio cpu con piu ALU e control units.

  oppure molte cpu possono lavorare in modo coordinato sulla stessa istruzione su dati diversi, creando un \textbf{array computer}

se invece eseguono istruzioni diverse su dati, con una memoria condivisa, diversi si parla di \textbf{multiprocessor systems}.

la forma piu complessa sono i \textbf{multicomputer systems}, con piu cpu, ognuna con memoria propria, collegate in rete.

\subsection{memoria}

vari tipi di memoria
\begin{itemize}
\item memoria volatile: perde il contenuto quando viene spenta(es:ram).
\item memoria non volatile: mantiene il contenuto quando spenta(es:rom, hard disk).
\item memoria online: sempre accessibile
\item memoria offline: il supporto deve essere montato
\end{itemize}

la memoria si organizza in celle, ogni cella è una sequenza di bit con il proprio indirizzo.

cella di 8 bit=byte.

molti calcolatori lavorano su blocchi da 32 o 64 bit, questi blocchi si chiamano word.

le word possono essere memorizzate in celle standard, occupando piu celle consecutive.
si puo fare in 2 modi:
\begin{itemize}
    \item big-endian: byte piu significativo all'indirizzo piu basso.
    \item little-endian: byte meno significativo all'indirizzo piu basso.
\end{itemize}

la \textbf{cache} è una memoria poco capiente ma  veloce, che viene usata per contenere le word piu usate.

la cpu prima cerca i dati nella cache, se non li trova li va a prendere in memoria principale.

\textbf{principio di località}: dati usati recentemente gli uni dagli altri sono spesso in locazoni vicine.

tipi di supporti:
\begin{itemize}
\item hard disk: memoria non volatile, lenta, grande capacita, usa piatti magnetici rotanti.(puo essere resa piu veloce con la tecnica RAID, che usa piu dischi in parallelo).
\item SSD: memoria non volatile, veloce, grande capacita, usa memoria flash, piu veloce ma meno capiente.
\item CD e DVD: memoria non volatile, usano supporti ottici, capacita limitata.
\end{itemize}

\section{porte logiche e circuiti combinatori}
Porte logiche sono basate sull'algebra di Boole, un'espressione booleana si costruisce con: le costanti di boole(0,1), gli opeartori booleani, e variabili(x,y, ecc..).

\textbf{mintermine}: un prodotto (AND) di tutte le variabili della funzione, ognuna presente una sola volta, negata o non negata, che vale 1 per una sola combinazione di valori delle variabili.

\textbf{forma canonica}: l'OR di tutti mintermini veri

porta nand è una porta logica utile per costruire circuiti combinatori, falsa solo quando a=1 e b=1.
è universale e facile da costruire con transistor

array logici programmmabili: collegando dei fusibili è possibile creare porte logiche personalizzate.

\subsection{mappe di karnaugh}

\textbf{mappe di karnaugh}: modo di rappresentare funzioni booleane. permettono di costruire un circuito combinatorio minimale.

tabella bidimensionale in cui ogni mintermine ha una cella, e la cella ha un valore, 1 se vale, se 0 se no.

puoi creare raggruppamenti che comprendono gruppi di certi letterali =1.

all'interno di una mappa di karnaugh una copertura si dice minimale quando:
\begin{itemize}
\item i suoi raggruppamenti non è contenuto in raggruppamenti piu grandi.
\item i suoi raggruppamenti contengono almeno una cella che non appare in altri raggruppamenti della copertura
\end{itemize}

\subsection{bus multi bit}

circuiti combinatori collegati a connessioni da piu bit sono detti \textbf{bus}

sono praticamente un raggruppamento di segnali e ogni coppia lavora separatamente come in una porta normale, per poi far uscire i seganli uno dopo l'altro.

\section{codice binario}
codifiche posizionali principali:
\begin{itemize}
\item binario
\item ottale
\item esadecimale
\end{itemize}

per convertire da bianrio a ottale prendi 3 cifre alla volta e calcola il numero, per esadecimale prendine 4.

i numeri possono anche essere codificati \textbf{in eccesso} cioe dato k= bits e bias= $2^{k-1}$. somma numero e bias, e codifica regolarmente il risultato.
 
es: -127 + bias(128) = 1.    1= 00000001

se poi vuoi decodificare, decodifica il binario nel numero e sottrai il bias.

nelle somme tra binari, il riporto finale nel complemento a 1 viene sommato all'inizio, nel complemento a 2 viene scartato.

puo verificarsi \textbf{overflow}: se i due addendi hanno segni diversi non accade mai, se hanno lo stesso segno e il risultato ha segno opposto, si verifica overflow.

\subsection{codifica  a virgola mobile}

composto da sue parti: \textbf{mantissa}(o frazione): numero, ed \textbf{esponente}: potenza

le operazioni su numeri floating point(virgola mobile) possono dare 2 tipi di errore
\begin{itemize}
\item overflow: numero in valore assoluto troppo grande
\item underflow: numero in valore assoluto troppo piccolo
\end{itemize}

\textbf{normalizzare} un numero significa scrivere un numero in una forma standard dove la mantissa ha sempre la stessa struttura.

in binario vuoi fare in modo che il numero piu significativo della mantissa(il primo) sia 1.

puoi farlo spostando il primo 1 a sinistra di x posti e poi sottraendo x all'esponente e ricodificandolo.

\subsection{standard di codifica}
IEEE 754 è lo standard piu usato per i floating point. definisce diversi formati tra cui Binary32 che usa 1 bit di segno, 8 di esponente e 23 di mantissa.

era impossibile codificare caratteri extraeuropei in ASCII quindi fu creato UNICODE, che usava 16 bit.
UNICODE pero usa troppi bit per i caratteri piu semplici ed e vicino oramai all'esaurimento, quindi fu creato UTF-8.
UTF-8 puo dinamicamente occupare da 1 a 4 byte, I bit iniziali indicano il formato specifico e la quantità di
bit utilizzati.

\subsection{bit di controllo}

i codici binari o in lettura o in scrittura possono essere soggette a errori, per evitare questo esistono i bit di controllo.

esistono sia bit di rilevazione che di correzione.\\

\textbf{distanza di Hamming}: è il numero di bit di differenza tra due parole. la distanza di hamming di un codice è invece la minima dist. di Hamming tra tutte  le parole del codice.

per rilevare d bit errati servono, la distanza di Hamming deve essere uguale a d+1, per correggerli deve essere d+2.

uno dei codici di controllo piu semplici e il \textbf{bit di parita}: un bit che fa in modo che il numero di 1 sia pari, la dist. di hamming minima risulta essere 2.

i bit di parita devono sempre rispettare l'equazione m(numero bit)+ r(num bit di contollo)+1 minore o uguale a $2^r$
e vanno collocati nelle posizioni equivalenti alle potenze di 2 (1,2,4,8,16 ....) e ognuno controlla un sottogruppo di bit.


\section{circuiti sequenziali}

alcuni circuiti possono memorizzare l'input in e ripeterlo, in questi casi l'output non dipende piu solo dall'input, ma anche da altre circostanze.

un esempio e il latch SR. il circuito contiene un ciclo e se entrambi gli input sono 0 il risultato e sconosiuto.

si puo fare in modo che il latch risponda agli input solo durante certi momenti mettendo gli input e il ciclo di clock in porte AND

il latch D ha un solo input e cio fa in modo che non si verifichi la situazion in cui entrambi gli input sono 1.

Il latch D cambia il proprio stato mentre il clock è attivo, durante la
fase 0 del clock memorizza l’ultimo valore di D alla fine della fase 1

i circuiti con \textbf{commutazione sul fronte}: ovvero due stati stabili che cambiano in base al clock, sono detti flip-flop

esistono vari flip-flop, noi usiamo il tipo D.

il DFF(flip-flop tipo D) cambia stato dopo il fronte di salita in base in base agli input che ha ricevuto durante il fronte di salita.

gli \textbf{one-bit-register}: memorizzano un bit nell'ultimo istante in cui load e stato attivato

collegando tanti one-bit-registers puoi creare un w-bit-register

esiste anche il \textbf{counter}: e un fcircuito sequenziale usato per crare i program counter, oltre a load ha reset che resetta a 0 il bit interno e inc che aumenta di 1 il valore memorizzato. se nessuno di questi comandi e usato ripete solo il val memorizzato.

una memoria con locazioni da w bit puo essere realizzata con w-bit-registers e un circuito chiamato DIrect Access Logic indica a quale accedere.
cosi si realizzano registri di memoria.

puo essere utili avere circuiti logici anche dopo le uscite delle memorie per indicare quale delle uscite dei registri deve essere portata su out.

\section{microarchitettura}

il livello della microarchitettura si occupa di utilizzare le parti del livello logico digitale per creare linguaggio macchina.

il processore hack ad esempio ha due registri D e d A che possono dare alla ALU i suoi 2 input,D puo contenere un precedente output, A un'istruzione o un precedente output.

il flusso dei dati tra componenti viene gestito con MUX.

i MUX e i bit di controllo vengono gestiti da una microarchitettura di circuiti combinatori. L'intero ciclo FDE viene completato in un clock.\\

le memorie realizzate con flip-flop sono dette SRAM, sono veloci ma costose per quanto riguarda il costo in bit.

SRAM vengono quindi usate per la cache , DRAM per la memoria centrale, e poi dischi.

il passaggio da una memoria all'altra si gestisce con paginazione.

Le DRAM o RAM dinamiche hanno un solo transister e un condensatore, che mantiene un bit.

visto che il condesatore puo perdere la propria carica, sono necessari periodi di refresh, cio le rende piu lente.

ci sono poi vari livelli di cache.

una piu piccola dentro al cip della CPU, una media nello stesso involucro della CPU e una piu grande esterna\\

con \textbf{localita temporale} si intende l'alta probabilita che la stessa cella venga acceduta in una breve distanza di tempo

con \textbf{localita spaziale} si intende l'alta probabilita che celle di memoria vicine vengano accedute a breve distanza di tempo.

esistono diversi metodi di gestione della cache. noi vediamo il "cache a corrispondenza diretta" o "direct mapped cache".

suddividi la memoria in blocchi di dimensione m.

crei n linee di cache di dimensione m. le linee sono iindicizzate da 0 a n-1.

blocchi di memoria vengono inseriti in certe linee di cache "ad orologio", e si tiene conto di quale blocco e dove.

ogni linea ha 1 booleano Valid che dice se la linea e occupta, data che contiene i dati e tag che indica il blocco della emoria principale contenuto.

quando l'accesso alla cache ha successo e il blocco di memoria e gia presente in cache, si dice che e avvenuto un cache hit, altrimenti e cache miss.
se cache miss, il blocco deve essere portato in cache, qui ce un momento in cui dati di cache e dati di memoria centrale non corrispondono, cio puo creare problemi.

esistono gli stessi prooblemi tra memoria centrale e memoria di massa(dischi), qui si usa la paginazione.\\

a differenza del processore hack, istruzione e operandi spesso sono caricate insieme, questo richiede un ciclo di clock molto lungo.

spesso si pre-carica la prossimo istruzione mentre la prima e in esecuzione, questo e gestito dall' IFU( instruction fetch unit)
Questo e un esempio di pipeline.

i salti pero possono essere problematici per le pipeline, visto che richiedono di scartare le istruzioni successive.
quindi architetture moderne cercano di predire i salti.

ci sono anche problemi di concorrenza e accesso a sezioni critiche.

\section{ISA del processore hack}

per usare un processore lo si deve programmare tramite un suo linguaggio assembly, un set di istruzioni detto "instruction set".

il linguaggio assembly corrisponde ad istruzioni macchina subito eseguibili. e praticamente una versione leggibile del binario.

il linguaggio macchina supportato dall'architettura dipende dall'instrucion set architecture(ISA)

possiamo definire l'ISA come l'insieme degli elementi dell'architettura visibili al compilatore.

ci sono due approcci per migliorare le architetture: RISC e CISC

la hack non e facilmente classificabile.

hack e una macchina a 16 bit costituita da 
\begin{itemize}
\item RAM: composta da registri a 16 bit. salva dati di lavoro
\item ROM: composta da registri a 16 bit, contiene istruzioni dei programmi da eseguire.
\item registro A
\item registro D
\item M: registro di memoria puntato da A
\item ALU per eseguire poi le istruzioni.
\item program counter: il registro che contiene l'indirizzo del registro ROM con la prossima istruzione.
\end{itemize}

esistono 2 tipi di istruzioni:
\begin{itemize}
\item A instruction: servono solo a caricare valori sul registro A.
\item C instruction: istruzioni che eseguono una computazione prelevando dai registri A, D ed M e poi registrando il nuovo valore.
\end{itemize}

le istruzioni C hanno 3 parti:
\begin{itemize}
\item dest: specifica dove memorizzare la computazione.
\item comp: specifica la computazione da eseguire.
\item jump: specifica se, dopo avere eseguito dest=comp, bisogna saltare a un'altra istruzione. Lo fa dicendo di aggiornare il PC al valore del registro A.

\end{itemize}

cose da ricordare:
\begin{itemize}
\item M è sempre uguale a MEM[A], quindi se @3; M=MEM[3]
\item mentre A e D sono registri della CPU, gli M sono celle di memoria della RAM.
\item l'architettura non supporta A+M o M+A, devi sempre fare D=M; D=D+A. 
\item puoi fare A=M, ma attento che se fai un altro @ cancelli A
\end{itemize}

\textbf{etichette}: da usare come se fossero valori, usate per indicare destinazioni per i salti.
divise in 2 parti: la dichiarazione, indicata da @, dove finisce il salto.

e l'uso di etichetta, da cui parte il salto, deve essere uguale al nome della destinazione.

\section{componenti hack}

chip memory composta da RAM(16k), chip screen(8k), usta per la mappa dello schermo. e chip keyboard, un singolo registro per il tasto usato.

lo schermo ha una funzionalita di tipo RAM,Esiste una corrispondenza diretta fra ogni pixel del
monitor ed i corrispondenti bit memorizzati ad opportuni
indirizzi all’interno del chip Screen.

il chip screen contiene 8k parole da 16 bit.

cpu contiene ALU e 3 registri, A,D, PC.

2 bit di controllo della ALU sono nr e zr

il primo bit del binario e 0 se si tratta di una A instruction.

\subsection{assembler}

assembler traduce assembly in linguaggio macchina(binario)

assembler hack traduce da ssembly hack a un file un numero binario a 16 bit per ogi riga in ASCII

\textbf{symbol table}: tabella con tutti i simboli, sia i predefiniti(R0....R15) che eventuali simboli, che vengono aggiunti man mano. a ognuno viene asseganto un valore.

processo di assemblaggio:
\begin{enumerate}
\item inizializzazione: si apre il file in input e si inizializza la symbol table con i simboli predefiniti.
\item prima passata: si passa l'input, inserendo etichette nella symbol table, e aggiungendo 1 a un contatore ogni volta che hai una A/C instruction. Quando incontri una definizione di etichetta(es: (loop)), le assegni il valore ddel contatore in quel momento +1 e non aumenti il contatore.
\item seconda passata: si apre in scrittura l'output e si assegna a ogni istruzione il suo valore. per le istruzioni con simbolo, si cerca in symbol table il valore del simbolo, se non ce(non e etichetta) gli si assegna un valore a partire da 16 e lo si memorizza in symbol table.
\end{enumerate}

\section{livello ISA}

ora parliamo dell'ISA in modo piu generico.

livello ISA rappresenta l'interfaccia tra hardware e software, non comprende solo l'instruction set ma anche tutto cio che e visibile al compilatore ed e necessario per generare codice macchina.

\textbf{formato di istruzioni}: set di regole per facilitare l'implementazione logico-digitale, in hack erano A/C instruction.

in un computer generico, le istruzioni ISA contengono:

\textbf{opcode} o codice operatio, cioe l'istruzione da eseguire(somma,and .... )

e gli operandi, rappresentati attraverso i loro indirizzi.

a differenza di hack istruzioni diverse possono usare un numero diverso di bit per la codifica in binario, inoltre anche il nunero di operandi puo cambiare.

si puo segliere se usare piu bit per opcode o per gli indirizzi(operandi), determinando il numero di indirizzi o un numero maggiore di operazioni.

anche la dimensione delle intere istruzioni puo caambiare in base alla word. istruzioni piu piccole occupano meno memoria ma sono meno facili da decodificare.

se ad esempio una word è 32 bit, e divis in 4 byte, i byte poi sono salvati in celle di memoria di ordinamenti fissati.

l'ordine puo essere:
\begin{itemize}
    \item big endian: 0-1-2-3
    \item little endian: 3-2-1-0
\end{itemize}

esistono diversi modi per indicare come reperire i vari operandi da usare:
\begin{itemize}
\item indirizzamento immediato: l'istruzione contiene gia l'operando da usare.
\item indirizzamento diretto: l'istruzione contiene l'indirizzo completo della cella di memoria da cui prendere l'operando.
\item indirizzamentoo a registro: l'operando viene preso da un registro.
\item indirizzamento a registro indiretto: l'operando viene prelevato dalla memoria a un indirizzo puntato da un registro.
\item indirizzamento indicizzato: l'istruzione contiene un "offset" che va sommata al contenuto di un registro per ottenere l'indirizzo di memoria.
\item indirizzamento a stack: Si considera una parte di memoria da gestire secondo un modalità LIFO
(last in-first out), ovvero tramite uno stack
\end{itemize}

inoltre ci sono 3 tipi di operazioni:
\begin{itemize}
\item trasferimento: è possibile trasferire dati da memoria a registri, da registri a memoria e da registro a registro.
\item operazioni aritmetico-logico binarie: esistono anche operazioni con floating point oltre che interi.
\item salti
\end{itemize}

\textbf{procedura}: serie di istruzioni che viene chiamata, esegue un compito, e torna al punto di partenza.

solitamente esistono istruzioni anche per la chiamata di procedura.

si ha la chiamata \textbf{CALL} che interrompe l'esecuzione sequenziale, tiene traccia del punto di partenza e comincia ad eseguire la procedura invocata.

il \textbf{return}(o ret) invece fa tornare a d eseguire l'istruzione dopo la chiamata, tipicamente inserendo l'indirizzo di ritorno nel program counter.

implementare le chiamate a procedure richiede inizializzare ed allocare la memoria necessaria ad eseguirle, tale spazio di memoria viene chiamato \textbf{activation record}(o record di attivazione) della procedura invocata.

i record di attivazione sono organizzati a stack(last in first out), quando termina una procedura si riattiva la precedente.

il record di attivazione si puo considerare l'insieme di tutti i dati necessari ad eseguire una singola chiamata di una procedura.

per gestire lo stack dei vari record di attivaazione, si usano 2 puntatori: FP(frame pointer) che punta all'inizio del record corrente e SP(stack pointer) che punta alla cima dello stack.

quando lo stack e vuoto SP=FP

poi man mano che aggiungi o togli funzioni o variabili SP cambia di continuo,  FP e fisso ma cambia al cambio della funzione. in cima a ogni funzione, subito sotto a dove sarebbe SP e sopra all'indirizzo di ritorno, ce un puntatore al FP precedente che permette di aggiornare FP nel posto giusto al ritorno sul record precedente.

come conponenti del record di attivazione abbiamo:
\begin{itemize}
\item parametri
\item indirizzo di ritorno: per rimettere in esecuzione il chiamante, cioe l'indirizzo dell'istruzione successiva al chiamante.
\item vecchio frame pointer: Serve per ripristinare FP al momento del ritorno al chiamante
\item variabili locali
\end{itemize}

questa organizzazione a stack permette di usare un'indirizzamento a stack e indicizzato per quanto riguarda al vslore corrente di FP.


serve uno stack per ogni thread in esecuzione.

ora esiste il problema di concorrenza, visto che ognuno di questi ha bisogno di uno spazio di memoria, ce il rischio che un programma scriva nella memoria sbagliata.

\subsection{trap}

\textbf{trap}: chiamata di procedura che si verifica al rilevamento di un errore rilevante.

fa trasferire il controllo a un processo detto \textbf{gestore di trap}

le trap sono quindi sincrone al programma, visto che vengono scatenate da un'istruzione del programma.

come le trap, gli \textbf{interrupt} sono condizioni che interrompono il programma per affidare il controllo a un gestore( detto interrupt service routine, o ISR).

gli interrupt pero non si riferiscono solo ad errori ma anche a notifiche ed eventi.

gli interrupt sono fondamentali per evitare il busy waiting.

gli interrupt sono invece asincroni, cioe sono scatenati da eventi indipendentemente dal programma in esecuzione.

Poi non e sempre bene che un interrupt interrompa l'esecuzione attuale, ad esempio l'ISR non dovrebbe essere interrotto da altri interrupt.
Per questo il sistema operativo puo \textbf{mascherare} un interrupt, facendo in odo che non interrompa. Certi interrupt importanti possono essere dichiarati non mascherabili.

si puo anche assegnare una priorita ad ogni interrupt creando una gerarchia di priorita.

\section{livello del sistema operativo}






\end{document}

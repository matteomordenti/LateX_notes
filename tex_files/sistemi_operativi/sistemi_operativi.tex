\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb} % Math packages
\usepackage{geometry}
\usepackage{hyperref} % Clickable links
\usepackage{graphicx} % Images

\geometry{a4paper, margin=1in}

\title{sistemi operativi riassunto}
\author{Matteo}
\date{\today}

\begin{document}


\maketitle

\section{processi}
Def processo: un attivita controllata da un programma che si svolge su un processore.

programma e un entita statica, un processo e dinamico.

il processo e l’attualizzazione del programma.

assioma del “finite process”:ogni processo viene eseguito a una velocita finita, costante ma sconosciuta.

Ad ogni istante, un processo può essere totalmente
descritto dalle seguenti componenti:
\begin{itemize}
\item La sua immagine di memoria, divisa in:

    \begin{enumerate}
       
\item la memoria assegnata al processo
(ad es. testo, dati, stack)

\item le strutture dati del S.O. associate al processo
(ad es. file aperti)
    \end{enumerate}

\item la sua immagine nel processore:
contenuto dei registri generali e speciali



\item il suo avanzamento del processo:
descrive lo stato corrente del processo: ad esempio, se è in
esecuzione o in attesa di qualche evento
\end{itemize}

piu processi possono eseguire lo stesso programma
stato dei processi:
\begin{itemize}
\item running
\item waiting: in attesa di qualche evento
\item ready: è pronto ma il processore e impegnato in qulacos'altro

\end{itemize}

\section{introduzione concorrenza}
gestione di processi multilpli:
\begin{itemize}
\item Multiprogramming:
più processi su un solo processore
parallelismo apparente
\item Multiprocessing:
più processi su una macchina con processori multipli
parallelismo reale
\item Distributed processing:
più processi su un insieme di computer distribuiti e
indipendenti
parallelismo reale
\end{itemize}
concorrenza: due programmi vengono eseguiti insieme con parallelismo reale o apparente

molte operazioni possono essere create come un insieme di thread concorrenti

interleaving: per ogni processore al massimo un processo alla volta e attivo, multipli processi sono alternati nel tempo

overlapping: piu proceessi sono esguiti contemporeanamente su piu processori, sono alteranti nello spazio

multiprogramming e multiprocessing condividono gli stessi errori derivanti dal fatto che non e possibile predirre gli istanti temporali in cui avvengono le operaziooni e i processi accedono a risorse condivise

\textbf{se il risultato di una programmazione concorrente dipende dalla temporizzazione  dei processi, si dice che quella programmazione contiene una} \underline{RACE CONDITION}

\underline{e necessario eliminare la race condition}
scrivere programmi concorrenti e piu difficile che scrivere programmi sequenziali perche errori possono anche venire da errori nelle iterazioni tra loro

esistono processi concorrenti “ignari l’uno dell’altro”, sono indipendenti m concorrono per le stesse risorse, il sistema deve arbitrarle  e sincronizzarle. questi non sono creati per lavorare insieme 

esisstono processi indirettamente a conoscenza uno dell’altro che non si conoscono per id ma interagiscono indirettamente tramite le risorse condivise, anche loro devono essere ccordinate e sincronizzate

poi ci sono processi direttamente a conoscenza uno dell’altro per id , che comunicano direttamente tramite messaggi, cooperano per certi scopi e informano anche altri processi, il sistema deve fornire meccanismi di comunicazione

la memoria puo essere condivisa o privata
\subsection{proprieta della concorrenza}
Una proprietà di un programma concorrente è un attributo
che rimane vero per ogni possibile storia di esecuzione del
programma stesso

esistono 2 tipi di proprieta:
\begin{itemize}
    

\item  safety: (nothing bad happens), l’bbiettivo e che se il programma va avanti vada nella direzione giusta
\item liveness:(something good eventually happens), il programma non si ferma mai
\end{itemize}
nei programmi concoorrenti safety significa evitare interferenza tra processsi nelle risorse condivise

liveness significa che la sincronizzazione non deve impedire al programma di andare avanti, cioe non e ammissibile che un processo debba attendere indefinitivamente
\subsection{problemi della concorrenza}
l'accesso ad una risorsa si dice \underline{mutualmente esclusivo} se ad
ogni istante, al massimo un processo può accedere a quella
risorsa

questo risolve il problema della non interferenza ma puo creare quello del \underline{deadlock}, cio avviene quando dei  processi si bloccano a vicenda per un motivo o per l’altro,  ad esempio il processo e bloccato perche ha bisogno di usare due processi contemporeanamente ma la mutua esclusione lo previene, o due processi hanno bisogno di una risorsa occupata dalll’altro.

\underline{non interferenza}: i processi non devono alterare l'esecuzione degli altri processi in modo non voluto.

\underline{starvation} invece e quando un processo e fermo perche ha bisogno di una risprsa ma altri processi continuano a saltargli davanti nella coda per la risorsa

\underline{azioni atomiche}: compiute in modo indivisibile, soddisfano la condizione o tutto  o niente, non interferisce con altri processi durante la sua esecuzione

certe azioni vanno eseguite in modo atomico per garantire la non interferenza

le parti di un programma che utilizzano una o piu risorse condivise vengono dette \underline{sezioni critiche}
\section{gestione problemi}
\subsection {intro}
obbiettivi:  
\begin{itemize}
    \item usare solo azioni atomiche nelle sezioni critiche
\item evitare blocchi(deadlock,starvation)
\item evitare attese inutili, si fa aspettare un processo solo se gli serve una risorsa sezione critica occupata
\end{itemize}
il sistema non capisce necessariamente da solo cosa e una sezione critica e cosa no quindi devi programmare i processi accordingly (es: se entri in sezione x=x++, e per entrare x deve essere 0)
quando entri in una sezione critica devi rispettare 4 proprieta:
\begin{itemize}
\item \underline{mutua esclusione}: max 1 processo attivo che deve accdere a quella risorsa
\item assenza di deadlock
\item assenza di delay non necessari: Un processo fuori dalla CS non deve ritardare l'ingresso della CS
da parte di un altro processo
\item eventual entry(assenza di starvation): ogni processo che lo richiede prima o poi accede alla risorsa
\end{itemize}
se  un processo entra in una sezione critica, prima o poi ne uscira, quindi un processo non puo terminare se non fuori da una CS(critical section)
si puo provare a gestire i CS tramite:
\begin{enumerate}
\item software: cioe si programmano i processsi apposta, rischi di fare errori ed e probabile avere busy waiting
\item hardware: utilizzano istruzioni speciali del linguaggio, progettate apposta, e efficente ma non general purpose
\item ci sono poi approcci basati sul S.O. o sul linguaggio di programmazione(es: semafori o monitor)
\end{enumerate}
\subsection{soluzioni software}
algoritmo di dekker

algoritmo di peterson(piu semplice)

sono entrambe soluzioni software, funzionano ma sono entrambe baste sul busy waiting, che non andrebbe usato.

\textbf{busy waiting}: controllo terativo di una condizione di accesso a una CS, cosi il processo rimane attivo ma non fa nulla di utile

\subsection{soluzioni hardware}
altrimenti si possono usare soluzioni hardware, cioe usare istruzioni speciali per l’hardware

esempio: si possono disabilitare gli interrupt in entrata alla CS e riabilitarli dopo

gli interrupt sono cio che danno il segnale per alternare i processi, senza e fisicamente impossibile non avere mutua esclusione

problemi:
\begin{itemize}
    \item danneggia il parallelismo
    \item si lascia ai processi la responsabilita di riattivare gli interrupt che puo generare errori
\item ha senso solo su uniprocessori
\end{itemize}
Le (quasi) sezioni critiche realizzate con istruzioni speciali vengono chiamate
spinlock

in generale, i processi hardware:
\begin{itemize}
\item possono generalmente essere applicati aqualsiasi numero di processi sia su sistemi mono che multiprocessori
\item semplice da verificare
\item puo essere utilizzato per sezioni criitiche multiple

gli svantaggi sono

\item  ce ancora busy waiting
\item non elimina problemi di starvation
\item e difficile da programmare
\end{itemize}
noi invece vorremmo paradigmi poco complessi e facili da implementare.
\section{semafori}
per avere un paradigma semplice ed efficace, si pensa ai semafori:

due o piu processi si mandano segnaali in modo che un processo rimanga bloccato in un punto specifico fino a quando non riceve un altro segnale

vi sono due operazioni:

v: usata per inviare il segnale

p: usata per attendere il segnale

il semaforo puo essere visto come una variabile intera inizializzato a un numero non negativo

p attende che il semaforo sia positivo e lo decrementa

v aumenta il valore del semaforo

v e p sono entrambe atomiche

struttura dati è a coda e ha una politica FIFO, senza si potrebbe avere starvation

non abbaimo eliminato il busy waiting ma lo abbiamo limitato a dentro le operazioni v e p.

\subsection{semafori binari}
un semaforo binario e un semaforo che puo assumere solo i valori 0 e 1, puo essere usato per garantire la mutua esclusione.

ha lo stesso potere espressivo di un semaforo normale.

\subsection{Problemi con i semafori}
i semafori non garantiscono l'assenza di deadlock e starvation, e compito del programmatore evitare questi problemi

ecco alcuni problemi calssici:
\begin{itemize}
    \item produttore-consumatore
    \item buffer limitato
    \item filosofi a cena 
    \item lettori-scrittori
\end{itemize}

passi secondo Andrews per risolvere questo tipo di problemi:
\begin {enumerate}
\item definire il problema, identificare i processi, specificare i problemi di sincronizzazione, introdurre
le variabili necessarie e definire un'invariante

\item abbozzare una soluzione, produrre un primo schema di soluzione, e identificare le regioni che
richiedono accesso atomico o mutualmente esclusivo

\item garantire l'invariante, controlla che l'invariante sia sempre verificato

\item implementare le azioni atomiche, esprimere le azioni atomiche e gli statement await utilizzando le primitive di
sincronizzazione disponibili

\end{enumerate}

essendo i semafori costrutti di basso livello, e facile commettere errori(ad es. scambiare di ordine P e V), per questo esistono costrutti di piu alto livello come i monitor

\section{monitor}

monitor consiste in

\begin{itemize}

\item dati locali
\item una sequenza di inizializzazione
\item una serie di procedure che operano sui dati locali
\end{itemize}

le caratteristiche principali sono:
\begin{itemize}
    \item i dati locali sono accesssibili sollo alle procedure del modulo stesso
    \item  un processo entra in un monitor invocando una delle sue
procedure
\item solo un processo alla volta può essere all'interno del monitor;
gli altri processi che invocano il monitor sono sospesi, in
attesa che il monitor diventi disponibile
\end{itemize}

sono costruiti un come gli oggetti in programmazione ad oggetti:
\begin{itemize}
\item codice di inizializzazione= costruttore
\item procedure entri= metodi pubblici(sono richiamabili dall'esterno)
\item dati locali= attributi privati
\item procedure interne= metodi privati
\end{itemize}

il monitor fornisce un meccanismo di mutua esclusione, e inoltre ha bisogno di un meccanismo di sincronizzazione

\subsection{sincronizzazione del monitor}

esiste la varibile di condizione C, che ha due operazioni:
\begin{itemize}
\item wait(C): viene rilasciata la mutua esclusione e il processo che la invoca viene sospeso e messo in attesa sulla coda di C
\item signal(C): se c'e un processo in attesa su C, uno di questi viene risvegliato e messo nella coda del monitor secondo FIFO, il chiamante viene sospeso e verra riattivato al rilascio della mutua esclusione.
 \end{itemize}
c.wait e c.signal sono diverse da p e v.

signal non ha effetto se non ci sono processi in attesa, wait e sempre bloccante, e il processo risvegliato da signal viene eseguito per primo.

\subsection{politiche di segnalazione}
una politica di signaling determina cosa succcede quando un thread fa signal su una condition variable
ne esistono diverse:
\begin{itemize}
    \item \textbf{signal urgent}: il thread che fa signal viene sospeso e il thread risvegliato prende la mutua esclusione, dobbiamo usare questo in questo corso.
    \item \textbf{signal and wait}: il thread che fa signal continua l'esecuzione e il thread risvegliato viene messo in coda per la mutua esclusione
    \item \textbf{signal and return}: il thread che fa signal continua l'esecuzione e il thread risvegliato prende la mutua esclusione
    \item \textbf{signal and continue}: il thread che fa signal continua l'esecuzione e il thread risvegliato viene messo in coda per la mutua esclusione
\end{itemize}

slide 164:
se value =0 allora wait, altrimenti il processo si esegue e value --
se signal, il processso chiamante si sospende e viene risvegliato un processo in attesa che riprende da subito dopo dove si era fermato

\section{messagge passing}

nei semafori e monitor, la comunicazione avvieme tramite memoria condivisa

il meccanismo detto: \textbf{message passing} è un paradigma di comunicazione tra processi,
la sincronizzazione avviene tramite lo scambio di messaggi e non semplici segnalazione

un messaggio è un insieme di dato formattati dal mittente e interpretati dal ricevente

un meccanismo di "scambio messaggi" copia le informazioni di un messaggio da uno spazio di
indirizzamento di un processo allo spazio di indirizzamento di
un altro processo

esistono le operazioni:
\begin{itemize}
\item send: manda il messaggio, il destinatario deve essere specificato
\item receive: riceve il messaggio, il mittente può essere specificato
\end{itemize}

il passaggio dallo spazio di indirizzamento del mittente a
quello del destinatario è mediato dal sistema operativo
(protezione memoria)


diversi tipi di message passing(MP):
\begin{enumerate}
    \item MP sincrono
\begin{itemize}
    \item send sincrono
\item receive bloccante
\end{itemize}

\item MP asincrono
\begin{itemize}
\item send asincrono
\item receive bloccante
\end{itemize}
\item MP completamente asincrono
\begin{itemize}
\item send asincrono
\item receive non bloccante
\end{itemize}

\end{enumerate}

\subsection{MP sincrono}
sintassi send: void \texttt{(ssend(msg\_t m, pid\_t dst)}

Il mittente spedisce il messaggio m al processo dst, restando
bloccato fino a quando dst non riceve il messaggio

sintassi receive:\texttt{ msg\_t sreceive(pid\_t snd)}

il destinatario riceve un messaggio dal processo snd; se il
mittente non ha ancora spedito alcun messaggio, il
destinatario si blocca in attesa di ricevere un messaggio

il destinatario può non essere specificato.

\subsection{MP asincrono}





\end{document}
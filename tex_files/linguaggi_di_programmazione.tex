\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb} % Math packages
\usepackage{geometry}
\usepackage{hyperref} % Clickable links
\usepackage{graphicx} % Images

\geometry{a4paper, margin=1in}

\title{linguaggi di programmazione}
\author{Matteo}
\date{\today}

\begin{document}


\maketitle
ricorda sul libro per modulo 1 capitoli da 1 a 5
\section {intro}
linguaggi imperativi , linguaggi dichiarativi, funzionali e logici
linguaggi imperativi
\begin{itemize}
\item basato sulla nozione di stato, le istruzioni sono comandi che cambiano lo stato
\item stato= insieme di locazioni di memoria contenente valori
\item generalmente di basso livello
\end{itemize}
linguaggi dichiarativi
\begin{itemize}
\item basati sulla nozionne di funzioni o relazione
\item le istruzioni sono dichiarazioni di nuovi valori
\end{itemize}
linguaggi funzionali
\begin{itemize}
    \item basati sullla nozione di funzione: risultato di un programma = valore esplicito di una espressione
    \item ricorsione
    \item programmare= costruire una funzione
\end{itemize}
linguaggi logici
\begin{itemize}
    \item basati sulla nozione di relazione: risultato di un programma = insieme di valori di variabili determinato da relazioni
    \item istruzioni = implicazioni logiche fra opportune formule , che possono essere viste come regole  di riscrittura
    \item programmare= definire la relazione che definisce il valore delle variabili di interesse
\end{itemize}
linguaggi orienatati agli oggetti: ora molto usati, sono linguaggi imperativi con alcune ,etodologie dichiarative.
Oggetti (istanze di opportune classi) che contengono i dati
(concetti imperativi) e metodi come funzioni per operare su
tali oggetti (concetti dichiarativi).


\section{Macchine astratte}
pag 28 :Ml molto complesso  da tradurre in una macchina fisica ad alto livello, quindi vengono costruite macchine fisiche solo per linguaggi di basso livello

altimenti crei u programma che trduce L e i suoi costrutti in L’, un linguaggio gia esistente implementabile su una macchina gia esistente; minore velocita rispetto al casoo precedente

altrimenti anziche programmi usi microprogrammi o firmware che traducono L in un liguaggio di basso livello e usano registri di sola lettura, garantendo buone prestazioni

pag 31 impl. inter. pura : non e vvera traduzione, I fa corrispondere a una certa parte di L una certa parte di Lo, poco efficente, I deve decodificare al momento. piu flessibile perche permette di  interagire direttamnete con l’esecuzione del programma e gli interpreti sono piu veloci da creare

impl. comp. pura: vera traduzione dal compilatore che avviene prima dell’esecuzione del programma. alcune informazioni del programma sorgente vanno perse che rende piu difficile interagire con il programma in tempo reale

vantaggi e svantaggi interpretazione:
\begin{itemize}

\item vantaggio: maggiore flessibilita, permette di interagire con l'interazione del programma.
\item vantaggio : piu veloce da realizzare
\item vantaggio : occupa meno memorio, non generando nuovo codice, problema meno sentito oggi.
\item svantaggio : la compilazione intterpretativa e meno efficente perche deve effettuare al momento dell'esecuzione un'interpretazione dei costrutti di L.
con diverse occorrenze dello stesso costrutto si richiedono ulteriori decodifiche ogni volta
\end{itemize}
vantaggi e svantaggi compilazione:
\begin{itemize}
\item vantaggio: il compilatore deve compilare una sola volta al''inizio poi i costrutti non devono essere decodificati ogni  volta
\item vantaggio: maggiore efficenza
\item savntaggio: perdita del codice sorgente.
se ci fosse un problema sarebbe difficile capire da dove si origiina l'errore
\end{itemize}
siamo a pag 35
\end{document}
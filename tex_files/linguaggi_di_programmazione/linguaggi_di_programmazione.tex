\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb} % Math packages
\usepackage{geometry}
\usepackage{hyperref} % Clickable links
\usepackage{graphicx} % Images

\geometry{a4paper, margin=1in}

\title{linguaggi di programmazione}
\author{Matteo}
\date{\today}

\begin{document}


\maketitle
ricorda sul libro per modulo 1 capitoli da 1 a 5
\section {intro}
linguaggi imperativi , linguaggi dichiarativi, funzionali e logici
linguaggi imperativi
\begin{itemize}
\item basato sulla nozione di stato, le istruzioni sono comandi che cambiano lo stato
\item stato= insieme di locazioni di memoria contenente valori
\item generalmente di basso livello
\end{itemize}
linguaggi dichiarativi
\begin{itemize}
\item basati sulla nozionne di funzioni o relazione
\item le istruzioni sono dichiarazioni di nuovi valori
\end{itemize}
linguaggi funzionali
\begin{itemize}
    \item basati sullla nozione di funzione: risultato di un programma = valore esplicito di una espressione
    \item ricorsione
    \item programmare= costruire una funzione
\end{itemize}
linguaggi logici
\begin{itemize}
    \item basati sulla nozione di relazione: risultato di un programma = insieme di valori di variabili determinato da relazioni
    \item istruzioni = implicazioni logiche fra opportune formule , che possono essere viste come regole  di riscrittura
    \item programmare= definire la relazione che definisce il valore delle variabili di interesse
\end{itemize}
linguaggi orienatati agli oggetti: ora molto usati, sono linguaggi imperativi con alcune ,etodologie dichiarative.
Oggetti (istanze di opportune classi) che contengono i dati
(concetti imperativi) e metodi come funzioni per operare su
tali oggetti (concetti dichiarativi).


\section{Macchine astratte}
pag 28 :Ml molto complesso  da tradurre in una macchina fisica ad alto livello, quindi vengono costruite macchine fisiche solo per linguaggi di basso livello

altimenti crei u programma che trduce L e i suoi costrutti in L’, un linguaggio gia esistente implementabile su una macchina gia esistente; minore velocita rispetto al casoo precedente

altrimenti anziche programmi usi microprogrammi o firmware che traducono L in un liguaggio di basso livello e usano registri di sola lettura, garantendo buone prestazioni

pag 31 impl. inter. pura : non e vvera traduzione, I fa corrispondere a una certa parte di L una certa parte di Lo, poco efficente, I deve decodificare al momento. piu flessibile perche permette di  interagire direttamnete con l’esecuzione del programma e gli interpreti sono piu veloci da creare

impl. comp. pura: vera traduzione dal compilatore che avviene prima dell’esecuzione del programma. alcune informazioni del programma sorgente vanno perse che rende piu difficile interagire con il programma in tempo reale

vantaggi e svantaggi interpretazione:
\begin{itemize}

\item vantaggio: maggiore flessibilita, permette di interagire con l'interazione del programma.
\item vantaggio : piu veloce da realizzare
\item vantaggio : occupa meno memorio, non generando nuovo codice, problema meno sentito oggi.
\item svantaggio : la compilazione intterpretativa e meno efficente perche deve effettuare al momento dell'esecuzione un'interpretazione dei costrutti di L.
con diverse occorrenze dello stesso costrutto si richiedono ulteriori decodifiche ogni volta
\end{itemize}
vantaggi e svantaggi compilazione:
\begin{itemize}
\item vantaggio: il compilatore deve compilare una sola volta al''inizio poi i costrutti non devono essere decodificati ogni  volta
\item vantaggio: maggiore efficenza
\item savntaggio: perdita del codice sorgente.
se ci fosse un problema sarebbe difficile capire da dove si origiina l'errore
\end{itemize}

siamo a pag 35
di fatto nei linguaggi reali sono presenti entrambe le tecniche.
ad esempio abbiamo linguaggio L, compilato in linguaggio intermedio Li, interpretato in lo
se l'interprete della macchina intermmedia e molto diverso dal linguaggio finale Lo diremo che e un implementazione interpretativa, se e quasi uguale e un implementazione compilatiiva.

la differnza tr acompletamente interpretattiva e mostly interpretattiva e che non tutti i costrutti devono essere simulati

per impl. mostly compilativa alcune funzionalita devono essere simulate perche Li non trova un corrispondente immediato in molto

ci sono tanti spettri intermedi, di solito si predilige flessibilita

di solito ci sono piu livelli di macchine astratte con i loro linguaggi e funzionalita.
praticamente tutto nell'informatica e creato attravero una gerarchi adi macchine astratte(programmi e linguaggi).

ogni livello accede a quello inferiore e aggiunge nuove funzionalita, in un certo senso creando un nuo liguaggioMnLn

cio peremtte un certo dominio sulla complessita del sistemaa e independenza tra i livelli

\textbf{macchina astratta}:
\underline{una formalizzazione astratta di un generico esecutore di algoritmi}
\underline{formalizzato attraverso un linguaggio di programmazione}

\textbf{interprete}:
\underline{un componente essenziale della macchina astratta che ne caratterizza}

\underline{ il comportamento, mettendo in relazione '"operazionale'' il linguaggio}

\underline{della macchina astratta col mondo fisico circostante}

\section{descrivere i linguaggi di programmazione}

secondo morris i linguaggi hanno tre campi che li descrivono:
\begin{itemize}
    \item \textbf{grammatica}: indica quali frasi sono corrette, i lessico si occupa delle singole parole come sequenze di segni, la sintassi delle frasi come sequenze di parole
    \item \textbf{semantica}:risponde alla domanda "cosa significa una frase corretta", per quanto riguarda i linguaggi artificiali, si tratta del loro scopo
    \item \textbf{pragmatica}:risponde alla domanda " come usare una frase corretta e sensata", si occupa dell'uso della frase rispetto al contesto
\end{itemize}
per quanto riguarda i linguaggi di programmazione si puo parlare anche di implementazione cio mediante quale processo le frasi "operative" del linguaggio realizzano il loro fine.

\subsection{grammatica e sintassi}
tecniche generative: espedienti trovati nell'ambito dei linguaggi naturali per limitare nelle grammatiche le ambiguita dei linguaggi naturali
non troppo utili per i ling. naturali, ma utilissimi nei ling. di programmazione

\subsubsection{grammatiche libere}
definito un insieme finito di elementi come \textbf{alfabeto}, dato un alfabetoA, e dato A*= insieme di stringhe finite di A.
un linguagggio e un sottoinsieme di A*, una grammatica formaale serve a definire un di stringhe tra quelle possibili su un dato alfabeto

grammatica libera da conteso composta sa 4 parti:
\begin{itemize}
    \item simbolii non terminali: insieme finito di simboli astratti che non compaionon nel concreto
    \item simboli terminali: insieme finito di simboli concreti che compaiono nelle stringhe del linguaggio
    \item produzioni: le regole di riscrittura che permettono di sostituire un simbolo non terminale con una sequenza di simboli terminali e non terminali
    \item simbolo iniziale da cui parte tuttoù
    \end{itemize}
   \textbf{derivazione}: sequenza di applicazioni delle produzioni che partendo dal simbolo iniziale porta a una stringa composta solo da simboli terminali
\subsubsection{alberi di derivazione}
   per i linguaggi di programmazione e importante conoscere gli \textbf{alberi radicati ordinati}:Un albero radicato e ordinato è una struttura finita con una radice e una sequenza ordinata di sottoalberi, ognuno dei quali è a sua volta un albero. La radice e il simbolo iniziale s, e ogni nodo e un simbolo(terminale o non).ogni nodo ha un solo padre.

   
\subsubsection{ambiguita}
Se vogliamo usare gli alberi di derivazione per descrivere
la struttura logica di una stringa siamo in una pessima situazione: la grammatica
dell'Esempio 2.3 non è in grado di assegnare 11na struttura 11nivoca alla stringa in
questione. A seconda di come è costruita la derivazione, la precedenza tra i due
operatori aritmetici varia.

\textbf{definizione}:Una grammatica G è ambigua se esiste almeno
una stringa di C[GJ che ammette più di un albero di derivazione.

ambiguita nasce dal fatto che almeno una stringa abbia piu alberi di derivazione ma non dal fatto che la stessa stringa abbia piu derivazioni.

una grammatica ambigua non puo essere usata per compilare(non sarebbe possibile una traduzione univoca), am e posiibile modificarla.

lo sforzo di creare una grammatica non ambigua puo portare a piu complessita e contorcimenti.

\subsection{vincoli sintattici contestuali}
alcune volte anche i linguaggi di programazione dipendono dal contesto.
ad esempio in c la variabile deve essere dichiarata prima di essere usata.
questi sono detti \underline{vincoli sintattici} 
e sono impossibili da descrivere in una grammatica libera da conttesto.
farlo e invece compito dei linguaggi formali, ed esistono grammatiche dette grammatiche contsetuali.

tuttavia queste sono molto complesse ed e comunque impossibile stabilire metodi di traduzione per questo il contesto e ignorato dalle grammatiche e espresso al megliob tramite linguaggio naturale.
ediante strumenti formali quali i sistemi di transizione, che vedremo nel
Paragrafo 2.5, dedicato alla semantica.

nel gergo dei linguaggi di programmazione ci si
riferisce ad essi come a \textbf{vincoli di semantica statica}

Nel gergo, "sintassi" significa in genere "descrivibile con una grammatica libera", "semantica statica" significa "descrivibile con vincoli contestuali verificabili staticamente sul testo del
programma", mentre ''semantica dinamica'' (o "semantica" tout court) si riferisce
a quanto attiene a come e quando il programma sarà eseguito.

La distinzione tra sintassi non contestuale e sintassi contestuale (cioè seman-
tica statica) è stabilita precisamente dalla potenza espressiva delle grammatiche
libere.

\subsubsection{sintassi astratta e concreta}
La grammatica di un linguaggio di programmazione definisce un linguaggio come
insieme di stringhe

non tutti gli alberi di derivazione corrispondono a programmi legali.

l'analisi di semantica statica ha il compito di selezionarne alcuni, quelli
che soddisfano 1 vincoli contestuali del linguaggio stesso. L'insieme degli alberi
che risultano da questo processo costituisce la \underline{sintassi astratta di un linguaggio}.

\subsection{compilatori}
la struttura logica del compilatore e un modello a cascata, in cui il proggramma sorgente viene tradotto iin varie rappresentazioni intermedie
fino ad arrivare al linguaggio oggetto

ci sono varie fasi
\begin{enumerate}
    \item analisi lessicale: il testo del programma sorgente viene suddiviso in token, insiemi di caratteri.(parole chiave, identificatori, operatori, ecc) (equivalente delle parole.)
    \item analisi sintattica: i token vengono raggruppati in frasi secondo la grammatica del linguaggio dall'analizzatore sintattico(o parser).
    \item analisi semantica: le frasi vengono verificate rispetto ai vincoli di semantica statica. viene costruita la tabella dei simboli.
    \item generazione del codice intermedio: viene prodotto un codice intermedio che rappresenta la struttura logica del programma, ci sono ancora ottimizzazioni da fare percio non e opportuna generare il codice oggetto
    \item ottimizzazione del codice intermedio: il codice intermedio viene migliorato per efficienza
    \item generazione del codice oggetto: il codice intermedio ottimizzato viene tradotto nel linguaggio macchina della piattaforma di destinazione
\end{enumerate}

\subsection{semantica}
la semantica di un linguaggio di programmazione e il significato delle sue frasi e la sua descrizione e piuttosto complessa.
Dovrebbe essere una descrizione sia precisa che flessibile che non ambigua.

esistono metodi formali per la descrizione semantica adatti ma ulcuni fenomeni semantici rendono la decrizione formale molto complessa.
percio per lo piu e usato il linguaggio naturale.

Ciò non toglie che metodi formali per la
semantica siano molto utilizzati nelle fasi preparatorie del progetto di un linguag-
gio, oppure per descriverne alcune caratteristiche particolari, dove la necessità di
evitare ambiguità è predominante rispetto alla semplicità.
esistono due grandi famiglie di metodi formali per la descrizione della semantica:
\begin{itemize}
    \item La semantica denotazionale è l' ap-
plicazione ai linguaggi di programmazione di tecniche sviluppate per la semantica
del linguaggio logico-matematico. Il significato di un programma è dato da una
funzione, che esprime il componamento input/output del programma stesso.
\item ell'approccio operazionale, invece, non vi sono entità esterne (per esempio
funzioni) da associare ai costrutti di un linguaggio. Usando tecniche opportune,
una semantica operazionale specifica il comportamento della macchina astratta,
ossia ne definisce formalmente l'interprete, facendo riferimento ad un formali-
smo (astratto) di più basso livello. ci possono essere tecniche che usano automi formali e altre che usano sistemi di regole logico-matematiche.

\end{itemize}

\subsection{pragmatica}
serve a capire a cosa serve una frase in un certo contesto.
si parla anche di stile di programmazione e metodi di progettazione del software

non ci interessa troppo in questo corso

\subsection{implementazione}
implementare un linguaggio vuol dire scriverne un compilatore
e realizzare una macchina astratta per il linguaggio oggetto del compilatore, op-
pure scriverne un interprete e realizzare la macchina astratta del linguaggio nel
quale l'interprete stesso è scritto oppure, come avviene nella pratica, un mix di
entrambe queste cose.

ancora una volta non ci interessa

\section{analisi lessicale dei linguaggi regoalari}

\subsection{intro}

los copo dell'analisi lessicale e riconoscere dnella stringa di ingresso gruppi di caratteri che corrispondono a certe caratteristiche sintattiche.
cosi la stringa di ingressso e trasformata in una sequenza di token.

Non c'è un motivo teorico per separare l'analisi sintattica da quella lessicale:
tutta 1'elaborazione del testo sorgente potrebbe essere condotta mediante le tecniche
 di analisi sintattica che tratteremo nel Capitolo 4. Tuttavia la separazione tra i
due tipi di analisi è molto utile perché le tecnologie per effettuare l'analisi lessicale sono più efficienti di quelle (più generali) usate per l'analisi sintattica.

\subsection{token}
un token e una coppia:
\begin{itemize}
\item il nome del token(il simbolo del token).
\item   il valore del token(la stringa di caratteri che lo rappresenta)
\end{itemize}

poi per ogni nome di token si definiscono quali sequenze di caratteri sono riconosciute come istanze(valori di quel token)

Le sequenze
di caratteri associate ad un token sono specificate mediante un pattern, cioè una
descrizione generale della forma che le sequenze di caratteri possono assumere.
Questa descrizione generale è data mediante espressioni regolari, un concetto che
introdurremo tra breve.

con tutto ci viene fatto una lista di token che viene passata al parser.

una stringa dell'alfabeto di ingresso che corrisponde ad un pattern si dice \textbf{lessema}
.ad un token possono corrispondere anche piu lessemi.

\subsection{espressioni regolari}








\end{document}